mX <- fCauchy.slow(iN,iT,dSigma)
# 1.2
fCauchy.fast <- function(iN,iT,dSigma) {
vU <- runif(iN * iT)
vX <- dSigma * tan((vU - 1/2)*pi)
mX <- matrix(vX, nrow = iT, ncol = iN, byrow = F)
return(mX)
}
mY <- fCauchy.fast(iN, iT, dSigma)
# 1.3
fn_estimateScale <- function(mX) {
iT <- dim(mX)[1]
iN <- dim(mX)[2]
# change all negative numbers to positive
mX[which(mX < 0)] <- -mX[which(mX < 0)]
vSigma <- rep(0, iN)
# loop over N columns, order each, and obtain its median.
for (i in 1:iN) {
if (iT %% 2 == 0) {
# if iT is even
vSigma[i] <- mean(mX[order(mX[, i]), i][(iT/2):(iT/2+1)]) #mean of 500:501
} else {
# if iT is odd
vSigma[i] <- mX[order(mX[, i]), i][ceiling(iT/2)] # 500
}
}
return(vSigma)
}
vSigma <- fn_estimateScale(mY)
# 1.4
hist(vSigma, breaks = 50, freq = F, main = 'Distribution of estimates',
xlab = 'Estimates', xlim = range(vSigma))
lines(seq(range(vSigma)[1],range(vSigma)[2],length.out = dim(mX)[1]),
dnorm(seq(range(vSigma)[1],range(vSigma)[2],length.out = dim(mX)[1]),
mean(vSigma),sd(vSigma)))
# 1.5
fn_findMax <- function(x0 = 0, fn, fn.prime, tol = 1e-5) {
iter = 0
dX = x0
while (abs(fn.prime(dX)) >= tol) {
iter = iter + 1
dX = dX + sign(fn.prime(dX))/sqrt(iter)
}
return(list('value' = dX, 'function value' = fn(dX), 'iterations' = iter))
}
fn <- function(dX) {
return(-0.2 * dX^3 + 3 * dX^2 + 5 * dX - 3)
}
fn.prime <- function(dX) {
return(-0.6 * dX^3 + 6 * dX + 5)
}
lMax <- fn_findMax(fn = fn, fn.prime = fn.prime)
vX <- seq(-10,10,0.01)
plot(vX,fn(vX), 'l')
abline(h = lMax$`function value`, v = lMax$value)
## Problem 2
# 2.1
mData <- readRDS("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/6. semester/Programming/CARL/2021 Exam Files (ordinÃ¦r)/Exam Zip folder/mData.R")
# 2.2
NegAvgLL <- function(theta, mR){
omegA <- theta[1]
alphA <- theta[2]
betA <- theta[3]
omegB <- theta[4]
alphB <- theta[5]
betB <- theta[6]
rho <- theta[7]
N <- dim(mR)[1]
sig <- matrix(0,N,2)
sig[1,1] <- omegA/(1 - alphA - betA)
sig[1,2] <- omegB/(1 - alphB - betB)
ll <- matrix(0,N-1)
for (n in seq(2,N)){
sig[n,1] <- omegA + alphA*mR[n-1,1]^2 + betA*sig[n-1,1]
sig[n,2] <- omegB + alphA*mR[n-1,2]^2 + betB*sig[n-1,2]
SIGMA <-  matrix(c( sig[n,1] , rho * sqrt(sig[n,1] * sig[n,2]),
rho * sqrt(sig[n,1] * sig[n,2]) , sig[n,2] ),
nrow = 2,ncol = 2)
ll[n-1]  <- -0.5* log(2 * pi) -0.5 * log( det(SIGMA) )
- 0.5 * ( mR[n,] ) %*% solve(SIGMA) %*% ( mR[n,] )
}
return(-mean(ll))
}
NegAvgLL.nocons <- function(theta, mR){
omegA <- theta[1]
alphA <- theta[2]
betA <- theta[3]
omegB <- theta[4]
alphB <- theta[5]
betB <- theta[6]
rho <- theta[7]
N <- dim(mR)[1]
sig <- matrix(0,N,2)
sig[1,1] <- omegA/(1 - alphA - betA)
sig[1,2] <- omegB/(1 - alphB - betB)
ll <- matrix(0,N-1)
for (n in seq(2,N)){
sig[n,1] <- omegA + alphA*mR[n-1,1]^2 + betA*sig[n-1,1]
sig[n,2] <- omegB + alphA*mR[n-1,2]^2 + betB*sig[n-1,2]
SIGMA <-  matrix(c( sig[n,1] , rho * sqrt(sig[n,1] * sig[n,2]),
rho * sqrt(sig[n,1] * sig[n,2]) , sig[n,2] ),
nrow = 2,ncol = 2)
ll[n-1]  <- -0.5 * log( det(SIGMA) )
- 0.5 * ( mR[n,] ) %*% solve(SIGMA) %*% ( mR[n,] )
}
return(-mean(ll))
}
# 2.3
vTheta <- c(sd(mData[,1])*0.05, 0.05, 0.90, sd(mData[,2])*0.05, 0.05, 0.90, 0)
lOpt <- optim(0, NegAvgLL(theta = vTheta, mR = mData), method = 'BFGS')
vTheta <- c(sd(mData[,1])*0.05, 0.05, 0.90, sd(mData[,2])*0.05, 0.05, 0.90, 0)
lOpt <- optim(vTheta, NegAvgLL(theta = vTheta, mR = mData), method = 'BFGS')
lOpt <- optim(vTheta, NegAvgLL, method = 'BFGS')
setwd("Exam/Problem Sets/Problem Set 1")
setwd("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/7. semester/Financial Econometrics/Problem Sets/Problem Set 1")
tickers <- read.csv("DJITicker.csv", sep = ";")
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
setwd("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/7. semester/Financial Econometrics/Problem Sets/Problem Set 1")
################################################################################
### Problem 1                                                                ###
################################################################################
# load list of tickers
tickers <- read.csv("DJITicker.csv", sep = ";")
# delete unlisted firms
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
tickers <- read.csv("DJITicker.csv", sep = ";")
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
library(quantmod, quietly = TRUE)
library(quantmod, quietly = TRUE)
date_min <- "2018-01-01"
date_max <- "2022-01-01"
# Create dummy dataframe for first ticker in ticker-list
returns_data <- getSymbols(
Symbols = tickers$Symbol[1],
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(tickers$Symbol[1], "Adjusted", sep = ".")]
names(returns_data)[1] <- tickers$Symbol[1]
for (ticker in tickers$Symbol[-1]) {
returns <- getSymbols(
Symbols = c(ticker),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(ticker, "Adjusted", sep = ".")]
returns_data$ticker <- returns
names(returns_data)[ncol(returns_data)] <- ticker
for (ticker in tickers$Symbol[-1]) {
returns <- getSymbols(
Symbols = c(ticker),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(ticker, "Adjusted", sep = ".")]
# append the column to the data-frame
returns_data$ticker <- returns
# set name of column to the ticker-name
names(returns_data)[ncol(returns_data)] <- ticker
}
tail(returns_data)
setwd("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/7. semester/Financial Econometrics/Problem Sets/Problem Set 1")
################################################################################
### Problem 1                                                                ###
################################################################################
# load list of tickers
tickers <- read.csv("DJITicker.csv", sep = ";")
# delete unlisted firms
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
setwd("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/7. semester/Financial Econometrics/Problem Sets/Problem Set 1")
################################################################################
### Problem 1                                                                ###
################################################################################
# load list of tickers
tickers <- read.csv("DJITicker.csv", sep = ";")
# delete unlisted firms
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
library(quantmod, quietly = TRUE)
date_min <- "2018-01-01"
date_max <- "2022-01-01"
returns_data <- getSymbols(
Symbols = tickers$Symbol[1],
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(tickers$Symbol[1], "Adjusted", sep = ".")]
names(returns_data)[1] <- tickers$Symbol[1]
for (ticker in tickers$Symbol[-1]) {
returns <- getSymbols(
Symbols = c(ticker),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(ticker, "Adjusted", sep = ".")]
# append the column to the data-frame
returns_data$ticker <- returns
# set name of column to the ticker-name
names(returns_data)[ncol(returns_data)] <- ticker
}
tail(returns_data)
pct_log_returns <- function(level_returns) {
#' calculates % log returns and returns object of same shape as input
#' math: y_{t}=(\ln(p_{t})-\ln(p_{t-1}))\cdot 100
return(
diff(log(level_returns)) * 100
)
}
returns_data <- pct_log_returns(returns_data)
returns_data
plot(returns_data, type = "l")
plot(returns_data$IBM, type = "l")
tickers
plot(returns_data, type = "l")
plot(returns_data)
setwd("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/7. semester/Financial Econometrics/Problem Sets/Problem Set 1")
################################################################################
### Problem 1                                                                ###
################################################################################
# load list of tickers
tickers <- read.csv("DJITicker.csv", sep = ";")
# delete unlisted firms
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
################################################################################
### Problem 2                                                                ###
################################################################################
library(quantmod, quietly = TRUE)
date_min <- "2018-01-01"
date_max <- "2022-09-15"
returns_data <- getSymbols(
Symbols = tickers$Symbol[1],
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(tickers$Symbol[1], "Adjusted", sep = ".")]
for (ticker in tickers$Symbol[-1]) {
returns <- getSymbols(
Symbols = c(ticker),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(ticker, "Adjusted", sep = ".")]
# append the column to the data-frame
returns_data$ticker <- returns
# set name of column to the ticker-name
names(returns_data)[ncol(returns_data)] <- ticker}
tail(returns_data)
pct_log_returns <- function(level_returns) {
#' calculates % log returns and returns object of same shape as input
#' math: y_{t}=(\ln(p_{t})-\ln(p_{t-1}))\cdot 100
return(
diff(log(level_returns)) * 100
)
}
returns_data <- pct_log_returns(returns_data)
# show returns of all tickers
plot(returns_data, type = 'l')
plot(returns_data$BA, type = 'l')
library(moments)
desc_stat <- matrix(data = NaN, nrow = dim(tickers)[1], ncol = 7)
colnames(desc_stat) <- c(
"mean", "median", "variance", "kurtosis", "skewness", "rho", "rho2"
)
rownames(desc_stat) <- tickers$Symbol
autocorrelation <- function(returns, exponent = 1) {
#' returns the autocorrelation coefficient for lag = 1
# `[2]` due to acf calculates both lag=0 and lag=1
return(
acf(
returns^exponent,
lag = 1,
na.action = na.pass,
plot = FALSE
)$acf[2]
)
}
desc_stat[, "mean"] <- colMeans(returns_data, na.rm = TRUE)
desc_stat[, "median"] <- apply(returns_data, 2, median, na.rm = TRUE)
desc_stat[, "variance"] <- apply(returns_data, 2, var, na.rm = TRUE)
desc_stat[, "kurtosis"] <- apply(returns_data, 2, kurtosis, na.rm = TRUE)
desc_stat[, "skewness"] <- apply(returns_data, 2, skewness, na.rm = TRUE)
desc_stat[, "rho"] <- apply(returns_data, 2, autocorrelation)
desc_stat[, "rho2"] <- apply(returns_data, 2, autocorrelation, exponent = 2)
# print descriptive statistics
desc_stat
snp <- getSymbols(
Symbols = c("^GSPC"),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste("GSPC", "Adjusted", sep = ".")]
# remove "Adjusted" from column name
names(snp)[1] <- "GSPC"
snp <- getSymbols(
Symbols = c("^GSPC"),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste("GSPC", "Adjusted", sep = ".")]
snp
snp[1]
names(snp)[1]
names(snp)[1] <- "GSPC"
snp_return <- pct_log_returns(snp)
plot(snp_return, type = 'l')
?plot
plot(snp_return, type = 'l', lwd=0.5)
plot(snp_return, type = 'l', lwd=1)
plot(snp_return, type = 'l', lwd=0.5, col = 'red')
plot(snp_return, type = 'l', lwd=0.5, col = 'cornflowerblue')
setwd("/Users/tobiasbrammer/Library/Mobile Documents/com~apple~CloudDocs/Documents/Aarhus Uni/7. semester/Financial Econometrics/Problem Sets/Problem Set 1")
################################################################################
### Problem 1                                                                ###
################################################################################
# load list of tickers
tickers <- read.csv("DJITicker.csv", sep = ";")
# delete unlisted firms
tickers <- tickers[!(tickers$Symbol == "UTX" | tickers$Symbol == "DWDP"), ]
################################################################################
### Problem 2                                                                ###
################################################################################
library(quantmod, quietly = TRUE)
date_min <- "2021-04-31"
date_max <- "2022-09-15"
# Create dummy dataframe for first ticker in ticker-list
returns_data <- getSymbols(
Symbols = tickers$Symbol[1],
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(tickers$Symbol[1], "Adjusted", sep = ".")]
names(returns_data)[1] <- tickers$Symbol[1]
for (ticker in tickers$Symbol[-1]) {
returns <- getSymbols(
Symbols = c(ticker),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(ticker, "Adjusted", sep = ".")]
# append the column to the data-frame
returns_data$ticker <- returns
# set name of column to the ticker-name
names(returns_data)[ncol(returns_data)] <- ticker}
date_min <- "2021-04-30"
returns_data <- getSymbols(
Symbols = tickers$Symbol[1],
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(tickers$Symbol[1], "Adjusted", sep = ".")]
names(returns_data)[1] <- tickers$Symbol[1]
# get remaining tickers in loop
for (ticker in tickers$Symbol[-1]) {
returns <- getSymbols(
Symbols = c(ticker),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste(ticker, "Adjusted", sep = ".")]
# append the column to the data-frame
returns_data$ticker <- returns
# set name of column to the ticker-name
names(returns_data)[ncol(returns_data)] <- ticker}
pct_log_returns <- function(level_returns) {
#' calculates % log returns and returns object of same shape as input
#' math: y_{t}=(\ln(p_{t})-\ln(p_{t-1}))\cdot 100
return(
diff(log(level_returns)) * 100
)
}
returns_data <- pct_log_returns(returns_data)
# show returns of all tickers
plot(returns_data, type = 'l')
plot(returns_data, type = 'l', lwd = 0.5)
plot(returns_data, type = 'l', lwd = 0.75)
plot(returns_data[1], type = 'l', lwd = 0.75)
plot(returns_data[,1], type = 'l', lwd = 0.75)
plot(returns_data[,seq(1,10,1)], type = 'l', lwd = 0.75)
plot(returns_data[,seq(1,5,1)], type = 'l', lwd = 0.75)
plot(returns_data[,seq(1,2,1)], type = 'l', lwd = 0.75)
plot(returns_data, type = 'l', lwd = 0.75)
################################################################################
### Problem 3                                                                ###
################################################################################
library(moments)
# placeholder for moments
desc_stat <- matrix(data = NaN, nrow = dim(tickers)[1], ncol = 7)
# set names of columns and rows
colnames(desc_stat) <- c(
"mean", "median", "variance", "kurtosis", "skewness", "rho", "rho2"
)
rownames(desc_stat) <- tickers$Symbol
# helper function to calculate acf
autocorrelation <- function(returns, exponent = 1) {
#' returns the autocorrelation coefficient for lag = 1
# `[2]` due to acf calculates both lag=0 and lag=1
return(
acf(
returns^exponent,
lag = 1,
na.action = na.pass,
plot = FALSE
)$acf[2]
)
}
desc_stat[, "mean"] <- colMeans(returns_data, na.rm = TRUE)
desc_stat[, "median"] <- apply(returns_data, 2, median, na.rm = TRUE)
desc_stat[, "variance"] <- apply(returns_data, 2, var, na.rm = TRUE)
desc_stat[, "kurtosis"] <- apply(returns_data, 2, kurtosis, na.rm = TRUE)
desc_stat[, "skewness"] <- apply(returns_data, 2, skewness, na.rm = TRUE)
desc_stat[, "rho"] <- apply(returns_data, 2, autocorrelation)
desc_stat[, "rho2"] <- apply(returns_data, 2, autocorrelation, exponent = 2)
# print descriptive statistics
desc_stat
################################################################################
### Problem 4                                                                ###
################################################################################
snp <- getSymbols(
Symbols = c("^GSPC"),
env = parent.frame(),
reload.Symbols = FALSE,
from = date_min,
to = date_max,
verbose = FALSE,
warnings = TRUE,
src = "yahoo",
symbol.lookup = TRUE,
auto.assign = FALSE
)[, paste("GSPC", "Adjusted", sep = ".")]
# remove "Adjusted" from column name
names(snp)[1] <- "GSPC"
# calculate log returns
snp_return <- pct_log_returns(snp)
plot(snp_return, type = 'l', lwd=0.75, col = 'cornflowerblue')
